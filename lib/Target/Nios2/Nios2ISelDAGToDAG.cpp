//===-- Nios2ISelDAGToDAG.cpp - A dag to dag inst selector for Nios2 --------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the NIOS2 target.
//
//===----------------------------------------------------------------------===//

#define DEBUG_TYPE "nios2-isel"
#include "Nios2.h"
#include "Nios2MachineFunction.h"
#include "Nios2RegisterInfo.h"
#include "Nios2Subtarget.h"
#include "Nios2TargetMachine.h"
#include "llvm/GlobalValue.h"
#include "llvm/Instructions.h"
#include "llvm/Intrinsics.h"
#include "llvm/Support/CFG.h"
#include "llvm/Type.h"
#include "llvm/CodeGen/MachineConstantPool.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/Target/TargetMachine.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

//===----------------------------------------------------------------------===//
// Instruction Selector Implementation
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// Nios2DAGToDAGISel - NIOS2 specific code to select NIOS2 machine
// instructions for SelectionDAG operations.
//===----------------------------------------------------------------------===//
namespace {

class Nios2DAGToDAGISel : public SelectionDAGISel {

    /// TM - Keep a reference to Nios2TargetMachine.
    Nios2TargetMachine &TM;

    /// Subtarget - Keep a pointer to the Nios2Subtarget around so that we can
    /// make the right decision when generating code for different targets.
    const Nios2Subtarget &Subtarget;

    public:
    explicit Nios2DAGToDAGISel(Nios2TargetMachine &tm) :
        SelectionDAGISel(tm),
        TM(tm), Subtarget(tm.getSubtarget<Nios2Subtarget>()) {}

    // Pass Name
    virtual const char *getPassName() const {
        return "NIOS2 DAG->DAG Pattern Instruction Selection";
    } 


    private:  
    // Include the pieces autogenerated from the target description.
#include "Nios2GenDAGISel.inc"

    /// getTargetMachine - Return a reference to the TargetMachine, casted
    /// to the target-specific type.
    const Nios2TargetMachine &getTargetMachine() {
        return static_cast<const Nios2TargetMachine &>(TM);
    }

    /// getInstrInfo - Return a reference to the TargetInstrInfo, casted
    /// to the target-specific type.
    const Nios2InstrInfo *getInstrInfo() {
        return getTargetMachine().getInstrInfo();
    }

    SDNode *getGlobalBaseReg();
    SDNode *Select(SDNode *N);

    // Complex Pattern.
    bool SelectAddr(SDNode *Op, SDValue N, 
            SDValue &Base, SDValue &Offset);


    // getI32Imm - Return a target constant with the specified
    // value, of type i32.
    inline SDValue getI32Imm(unsigned Imm) {
        return CurDAG->getTargetConstant(Imm, MVT::i32);
    }
};

}

/// getGlobalBaseReg - Output the instructions required to put the
/// GOT address into a register.
SDNode *Nios2DAGToDAGISel::getGlobalBaseReg() {
  unsigned GlobalBaseReg = getInstrInfo()->getGlobalBaseReg(MF);
  return CurDAG->getRegister(GlobalBaseReg, TLI.getPointerTy()).getNode();
}

/// ComplexPattern used on Nios2InstrInfo
/// Used on Nios2 Load/Store instructions
bool Nios2DAGToDAGISel::
SelectAddr(SDNode *Op, SDValue Addr, SDValue &Offset, SDValue &Base)
{
    // if Address is FI, get the TargetFrameIndex.
    if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
        Base   = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
        Offset = CurDAG->getTargetConstant(0, MVT::i32);
        return true;
    }

    // on PIC code Load GA
    if (TM.getRelocationModel() == Reloc::PIC_) {
        if ((Addr.getOpcode() == ISD::TargetGlobalAddress) || 
            (Addr.getOpcode() == ISD::TargetConstantPool) ||
            (Addr.getOpcode() == ISD::TargetJumpTable)){
            Base   = CurDAG->getRegister(Nios2::GP, MVT::i32);
            Offset = Addr;
            return true;
        }
    } else {
        if ((Addr.getOpcode() == ISD::TargetExternalSymbol ||
                    Addr.getOpcode() == ISD::TargetGlobalAddress))
            return false;
    }    

    // Operand is a result from an ADD.
    if (Addr.getOpcode() == ISD::ADD) {
        if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1))) {
            if (Predicate_immSExt16(CN)) {

                // If the first operand is a FI, get the TargetFI Node
                if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>
                        (Addr.getOperand(0))) {
                    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
                } else {
                    Base = Addr.getOperand(0);
                }

                Offset = CurDAG->getTargetConstant(CN->getZExtValue(), MVT::i32);
                return true;
            }
        }
    }

    Base   = Addr;
    Offset = CurDAG->getTargetConstant(0, MVT::i32);
    return true;
}

/// Select instructions not customized! Used for
/// expanded, promoted and normal instructions
SDNode* Nios2DAGToDAGISel::Select(SDNode *Node) 
{
    unsigned Opcode = Node->getOpcode();
    DebugLoc dl = Node->getDebugLoc();

    // Dump information about the Node being selected
    DEBUG(errs() << "Selecting: "; Node->dump(CurDAG); errs() << "\n");

    // If we have a custom node, we already have selected!
    if (Node->isMachineOpcode()) {
        DEBUG(errs() << "== "; Node->dump(CurDAG); errs() << "\n");
        return NULL;
    }

    ///
    // Instruction Selection not handled by the auto-generated 
    // tablegen selection should be handled here.
    /// 
    switch(Opcode) {

        default: break;

        case ISD::SUBE:
        case ISD::ADDE: {
            SDValue InFlag = Node->getOperand(2), CmpLHS;
            unsigned Opc = InFlag.getOpcode(), MOp;

            assert(((Opc == ISD::ADDC || Opc == ISD::ADDE) ||
                   (Opc == ISD::SUBC || Opc == ISD::SUBE)) &&
                   "(ADD|SUB)E flag operand must come from (ADD|SUB)C/E insn");

            if (Opcode == ISD::ADDE) {
               CmpLHS = InFlag.getValue(0);
               MOp = Nios2::ADD;
            } else {
               CmpLHS = InFlag.getOperand(0);
               MOp = Nios2::SUB;
            }

            SDValue Ops[] = { CmpLHS, InFlag.getOperand(1) };

            SDValue LHS = Node->getOperand(0);
            SDValue RHS = Node->getOperand(1);

            EVT VT = LHS.getValueType();
            SDNode *Carry = CurDAG->getMachineNode(Nios2::CMPLTu, dl, VT,
                                                  Ops, 2);
            SDNode *AddCarry = CurDAG->getMachineNode(Nios2::ADD, dl, VT,
                                                     SDValue(Carry,0), RHS);

            return CurDAG->SelectNodeTo(Node, MOp, VT, MVT::Flag,
                                        LHS, SDValue(AddCarry,0));
        }

                        // Get target GOT address.
        case ISD::GLOBAL_OFFSET_TABLE:
            return getGlobalBaseReg();

        /// Handle direct and indirect calls when using PIC. On PIC, when 
        /// GOT is smaller than about 64k (small code) the GA target is 
        /// loaded with only one instruction. Otherwise GA's target must 
        /// be loaded with 3 instructions. 
        case Nios2ISD::Call: {
            if (TM.getRelocationModel() == Reloc::PIC_) {
                unsigned LastOpNum = Node->getNumOperands()-1;
                SDValue Chain  = Node->getOperand(0);
                SDValue Callee = Node->getOperand(1);
                SDValue T7Reg = CurDAG->getRegister(Nios2::T7, MVT::i32);
                SDValue InFlag;

                // Skip the incomming flag if present
                if (Node->getOperand(LastOpNum).getValueType() == MVT::Flag)
                    LastOpNum--;

                if ( (isa<GlobalAddressSDNode>(Callee)) ||
                        (isa<ExternalSymbolSDNode>(Callee)) )
                {
                    /// Direct call for global addresses and external symbols
                    SDValue GPReg = CurDAG->getRegister(Nios2::GP, MVT::i32);

                    // Use load to get GOT target
                    SDValue Ops[] = { Callee, GPReg, Chain };
                    SDValue Load = SDValue(CurDAG->getMachineNode(Nios2::LDW, dl, MVT::i32, 
                                                                 MVT::Other, Ops, 3), 0);
                    Chain = Load.getValue(1);

                    // Call target must be on T7
                    Chain = CurDAG->getCopyToReg(Chain, dl, Nios2::T7, Load, InFlag);
                } else 
                    /// Indirect call
                    Chain = CurDAG->getCopyToReg(Chain, dl, Nios2::T7, Callee, InFlag);

                // Map the JmpLink operands to JALR
                SDVTList NodeTys = CurDAG->getVTList(MVT::Other, MVT::Flag);
                SmallVector<SDValue, 8> Ops;
                Ops.push_back(CurDAG->getRegister(Nios2::T7, MVT::i32));

                for (unsigned i = 2, e = LastOpNum+1; i != e; ++i)
                    Ops.push_back(Node->getOperand(i));
                Ops.push_back(Chain);
                Ops.push_back(Chain.getValue(1));

                // Emit call
                SDNode *ResNode = CurDAG->getMachineNode(Nios2::CALLR, dl, NodeTys,
                                                         &Ops[0], Ops.size());
                // Replace Chain and InFlag
                ReplaceUses(SDValue(Node, 0), SDValue(ResNode, 0));
                ReplaceUses(SDValue(Node, 1), SDValue(ResNode, 1));
                return ResNode;
            } 
        }
    }

    // Select the default instruction
    SDNode *ResNode = SelectCode(Node);

    DEBUG(errs() << "=> ");
    if (ResNode == NULL || ResNode == Node)
        DEBUG(Node->dump(CurDAG));
    else
        DEBUG(ResNode->dump(CurDAG));
    DEBUG(errs() << "\n");
    return ResNode;
}

/// createNios2ISelDag - This pass converts a legalized DAG into a 
/// NIOS2-specific DAG, ready for instruction scheduling.
FunctionPass *llvm::createNios2ISelDag(Nios2TargetMachine &TM) {
    return new Nios2DAGToDAGISel(TM);
}
